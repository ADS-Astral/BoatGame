import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

const loadingEl = document.getElementById("loading");

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = 1.5;
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(12, 8, 16);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 2, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.07;
controls.update();

const hemiLight = new THREE.HemisphereLight(0xcfe8ff, 0x32394b, 1.1);
scene.add(hemiLight);

const textureLoader = new THREE.TextureLoader();
const diffuse = textureLoader.load("Water_Diffuse.jpg", (tex) => {
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(100, 100);
});
const normal = textureLoader.load("Water_Normal.jpg", (tex) => {
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(100, 100);
});

const maxRogueWaves = 2;
const waveConfig = {
  ampMin: 60,
  ampMax: 80,
  speedMin: 12,
  speedMax: 28,
  sigmaAlong: 35,
  sigmaAcross: 110,
  spawnDistance: 900,
  travelMax: 2200,
  respawnDelay: [1.5, 4], // seconds between waves per slot
};
const waves = Array.from({ length: maxRogueWaves }, () => ({
  amplitude: 0,
  sigmaAlong: waveConfig.sigmaAlong,
  sigmaAcross: waveConfig.sigmaAcross,
  speed: 0,
  dir: new THREE.Vector2(),
  center: new THREE.Vector2(),
  traveled: 0,
  active: false,
  cooldown: 0,
}));

const gerstnerWaves = [
  { dir: new THREE.Vector2(1, 0), amp: 1.6, len: 120, speed: 1.5, steep: 0.45 },
  { dir: new THREE.Vector2(0.3, 1).normalize(), amp: 1.2, len: 90, speed: 1.7, steep: 0.4 },
  { dir: new THREE.Vector2(-0.8, 0.6).normalize(), amp: 0.9, len: 60, speed: 2.2, steep: 0.35 },
];

const groundBaseHeight = -0.01;
const groundSize = 1000;
const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 200, 200);
const groundMaterial = new THREE.MeshStandardMaterial({
  map: diffuse,
  normalMap: normal,
  roughness: 0.5,
  metalness: 0.05,
});
applyGerstnerWaves(groundMaterial);
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI / 2;
ground.position.y = groundBaseHeight;
ground.receiveShadow = true;
scene.add(ground);

const pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();

new RGBELoader().load(
  "HDRI_Sky_16k.hdr",
  (hdr) => {
    const envMap = pmremGenerator.fromEquirectangular(hdr).texture;
    scene.environment = envMap;
    scene.background = envMap;
    hdr.dispose();
    pmremGenerator.dispose();
  },
  undefined,
  (err) => {
    console.error("Failed to load HDR:", err);
  }
);

const controlModes = { CAR: "car", SPECTATOR: "spectator" };
let controlMode = controlModes.CAR;

const vehicle = {
  object: null,
  velocity: 0,
  yaw: 0,
  maxSpeed: 32,
  accel: 18,
  brake: 14,
  drag: 4.5,
  steerRate: 1.8,
  vy: 0,
  pitch: 0,
  roll: 0,
  airborne: false,
  driftVel: 0,
  driftScale: 14,
  driftDamp: 6,
  driftMax: 10,
  turboMaxMult: 1.6,
  turboAccelMult: 1.4,
  onWave: false,
  surfaceHeight: 0,
  surfaceGradX: 0,
  surfaceGradZ: 0,
};

const followCamera = {
  distance: 12,
  height: 5,
  lookAhead: 6,
  stiffness: 6,
};

const gltfLoader = new GLTFLoader();
gltfLoader.setPath("./");
gltfLoader.setCrossOrigin("anonymous");
gltfLoader.load(
  "boat.glb",
  (gltf) => {
    gltf.scene.traverse((obj) => {
      if (obj.isMesh) {
        obj.castShadow = true;
        obj.receiveShadow = true;
      }
    });
    gltf.scene.position.set(0, 0, 0);
    gltf.scene.rotation.y = Math.PI / 2;
    vehicle.object = gltf.scene;
    vehicle.yaw = gltf.scene.rotation.y;
    scene.add(gltf.scene);
    controls.target.copy(gltf.scene.position);

    loadingEl.textContent = "Car mode (H to toggle)";
  },
  (event) => {
    if (event.total > 0) {
      const pct = ((event.loaded / event.total) * 100).toFixed(0);
      loadingEl.textContent = `Loading boat ${pct}%`;
    } else {
      loadingEl.textContent = "Loading boat...";
    }
  },
  (error) => {
    loadingEl.textContent = "Failed to load boat.glb";
    console.error("GLTF load error", error);
  }
);

const moveState = {
  forward: false,
  back: false,
  left: false,
  right: false,
  flip: false,
  somersault: false,
  turbo: false,
};
const spectatorSpeed = 12;
const worldUp = new THREE.Vector3(0, 1, 0);

const cameraDir = new THREE.Vector3();
const strafeDir = new THREE.Vector3();
const moveDelta = new THREE.Vector3();
const tmpForward = new THREE.Vector3();
const camDesired = new THREE.Vector3();
const camLook = new THREE.Vector3();
let lastTime = performance.now();
let shaderTime = 0;
const boatHeightDamp = 8;
const boatSurfaceSmooth = 6;
const hudEl = document.getElementById("hud");
const hudValue = hudEl?.querySelector(".value");
const minimapCanvas = document.getElementById("minimap-canvas");
const minimapCtx = minimapCanvas?.getContext("2d") || null;
const minimapRange = 800;

controls.enabled = controlMode === controlModes.SPECTATOR;

function setKeyState(code, isDown) {
  switch (code) {
    case "KeyW":
    case "ArrowUp":
      moveState.forward = isDown;
      break;
    case "KeyS":
    case "ArrowDown":
      moveState.back = isDown;
      break;
    case "KeyA":
    case "ArrowLeft":
      moveState.left = isDown;
      break;
    case "KeyD":
    case "ArrowRight":
      moveState.right = isDown;
      break;
    case "KeyR":
      moveState.flip = isDown;
      break;
    case "KeyE":
      moveState.somersault = isDown;
      break;
    case "ShiftLeft":
    case "ShiftRight":
      moveState.turbo = isDown;
      break;
    default:
      break;
  }
}

function toggleMode() {
  controlMode =
    controlMode === controlModes.CAR ? controlModes.SPECTATOR : controlModes.CAR;
  controls.enabled = controlMode === controlModes.SPECTATOR;
  if (vehicle.object && controlMode === controlModes.SPECTATOR) {
    controls.target.copy(vehicle.object.position);
  }
  loadingEl.textContent =
    controlMode === controlModes.CAR
      ? "Car mode (H to toggle)"
      : "Spectator mode (H to toggle)";
}

window.addEventListener("keydown", (e) => {
  if (e.code === "KeyH" && !e.repeat) {
    toggleMode();
    return;
  }
  setKeyState(e.code, true);
});
window.addEventListener("keyup", (e) => {
  if (e.code === "KeyH") return;
  setKeyState(e.code, false);
});

function updateCar(dt) {
  if (!vehicle.object) return;

  const steerInput = (moveState.left ? 1 : 0) + (moveState.right ? -1 : 0);
  const accelInput = (moveState.forward ? 1 : 0) + (moveState.back ? -1 : 0);
  const maxSpeed = vehicle.maxSpeed * (moveState.turbo ? vehicle.turboMaxMult : 1);

  if (accelInput !== 0) {
    let accelRate = accelInput > 0 ? vehicle.accel : vehicle.brake;
    if (accelInput > 0 && moveState.turbo) accelRate *= vehicle.turboAccelMult;
    vehicle.velocity += accelInput * accelRate * dt;
  } else {
    const drag = Math.sign(vehicle.velocity) * vehicle.drag * dt;
    if (Math.abs(vehicle.velocity) > Math.abs(drag)) {
      vehicle.velocity -= drag;
    } else {
      vehicle.velocity = 0;
    }
  }

  vehicle.velocity = THREE.MathUtils.clamp(vehicle.velocity, -maxSpeed * 0.4, maxSpeed);

  const speedFactor = THREE.MathUtils.clamp(
    Math.abs(vehicle.velocity) / maxSpeed,
    0,
    1
  );
  vehicle.yaw +=
    steerInput * vehicle.steerRate * speedFactor * dt * Math.sign(vehicle.velocity || 1);

  tmpForward.set(Math.sin(vehicle.yaw), 0, Math.cos(vehicle.yaw));
  strafeDir.crossVectors(tmpForward, worldUp).normalize();

  const desiredDrift =
    steerInput *
    vehicle.driftScale *
    Math.sign(vehicle.velocity || 1) *
    Math.min(1, Math.abs(vehicle.velocity) / maxSpeed);
  const clampedDrift = THREE.MathUtils.clamp(desiredDrift, -vehicle.driftMax, vehicle.driftMax);
  vehicle.driftVel = THREE.MathUtils.damp(
    vehicle.driftVel,
    clampedDrift,
    vehicle.driftDamp,
    dt
  );

  vehicle.object.position.addScaledVector(tmpForward, vehicle.velocity * dt);
  vehicle.object.position.addScaledVector(strafeDir, vehicle.driftVel * dt);

  const wasOnWave = vehicle.onWave;
  vehicle.onWave = false;

  const groundInfo = getGroundInfo(
    vehicle.object.position.x,
    vehicle.object.position.z
  );
  const gerstner = sampleGerstner(
    vehicle.object.position.x,
    vehicle.object.position.z,
    shaderTime
  );

  const targetSurfHeight = groundInfo.height + gerstner.height;
  const targetGradX = groundInfo.gradX + gerstner.gradX;
  const targetGradZ = groundInfo.gradZ + gerstner.gradZ;
  vehicle.surfaceHeight = THREE.MathUtils.damp(
    vehicle.surfaceHeight || targetSurfHeight,
    targetSurfHeight,
    boatSurfaceSmooth,
    dt
  );
  vehicle.surfaceGradX = THREE.MathUtils.damp(
    vehicle.surfaceGradX || targetGradX,
    targetGradX,
    boatSurfaceSmooth,
    dt
  );
  vehicle.surfaceGradZ = THREE.MathUtils.damp(
    vehicle.surfaceGradZ || targetGradZ,
    targetGradZ,
    boatSurfaceSmooth,
    dt
  );

  const travelSign = vehicle.velocity >= 0 ? 1 : -1;
  const slopeAlongForward =
    vehicle.surfaceGradX * tmpForward.x +
    vehicle.surfaceGradZ * tmpForward.z;
  const slopeAlongTravel = slopeAlongForward * travelSign;

  vehicle.vy -= 25 * dt;
  vehicle.object.position.y += vehicle.vy * dt;

  const targetY = vehicle.surfaceHeight;
  const verticalError = targetY - vehicle.object.position.y;
  const nearSurface = verticalError >= -2;

  if (nearSurface) {
    vehicle.object.position.y = THREE.MathUtils.damp(
      vehicle.object.position.y,
      targetY,
      boatHeightDamp,
      dt
    );
    if (vehicle.airborne && verticalError > -0.2) {
      vehicle.roll = 0;
    }
    vehicle.airborne = false;
    vehicle.vy = 0;
    vehicle.onWave = groundInfo.onWave;

    const targetPitch = Math.atan2(slopeAlongForward, 1);
    vehicle.pitch = THREE.MathUtils.damp(
      vehicle.pitch,
      targetPitch,
      10,
      dt
    );
    vehicle.roll = THREE.MathUtils.damp(vehicle.roll, 0, 10, dt);

    const uphill = Math.max(0, slopeAlongTravel);
    const slopePenalty = uphill * 30;
    vehicle.velocity = Math.max(0, vehicle.velocity - slopePenalty * dt);

    if (groundInfo.onWave) {
      const climbLift = Math.max(0, vehicle.velocity) * uphill * 0.6;
      vehicle.vy = Math.max(vehicle.vy, climbLift);
    }
  } else {
    vehicle.airborne = true;
    if (wasOnWave) {
      const launchLift =
        Math.abs(vehicle.velocity) * Math.max(0, slopeAlongTravel) * 0.8;
      vehicle.vy = Math.max(vehicle.vy, launchLift);
    }
    const spinRate = 4 * Math.PI;
    if (moveState.flip) vehicle.roll += spinRate * dt;
    if (moveState.somersault) vehicle.pitch += spinRate * dt;
  }

  vehicle.object.rotation.set(vehicle.pitch, vehicle.yaw, vehicle.roll);
  controls.target.copy(vehicle.object.position);
}

function updateFollowCamera(dt) {
  if (!vehicle.object) return;

  tmpForward.set(Math.sin(vehicle.yaw), 0, Math.cos(vehicle.yaw));
  camDesired.copy(vehicle.object.position);
  camDesired.addScaledVector(tmpForward, -followCamera.distance);
  camDesired.y += followCamera.height;

  camera.position.lerp(
    camDesired,
    1 - Math.exp(-followCamera.stiffness * dt)
  );

  camLook.copy(vehicle.object.position);
  camLook.addScaledVector(tmpForward, followCamera.lookAhead);
  camera.lookAt(camLook);
}

function updateSpectator(dt) {
  camera.getWorldDirection(cameraDir);
  cameraDir.y = 0;
  cameraDir.normalize();

  strafeDir.crossVectors(cameraDir, worldUp).normalize();

  moveDelta.set(0, 0, 0);
  if (moveState.forward) moveDelta.add(cameraDir);
  if (moveState.back) moveDelta.sub(cameraDir);
  if (moveState.left) moveDelta.sub(strafeDir);
  if (moveState.right) moveDelta.add(strafeDir);

  if (moveDelta.lengthSq() > 0) {
    moveDelta.normalize().multiplyScalar(spectatorSpeed * dt);
    camera.position.add(moveDelta);
    controls.target.add(moveDelta);
  }

  controls.update();
}

function handleResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
window.addEventListener("resize", handleResize);

function animate() {
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;
  shaderTime += dt;

  updateWave(dt);
  updateGerstnerTime(shaderTime);

  if (controlMode === controlModes.CAR) {
    updateCar(dt);
    updateFollowCamera(dt);
  } else {
    updateSpectator(dt);
  }

  renderer.render(scene, camera);
  renderMinimap();
  requestAnimationFrame(animate);
}

animate();

function sampleSingleWave(w, x, z) {
  if (!w.active) return { height: 0, dHdx: 0, dHdz: 0 };
  const dx = x - w.center.x;
  const dz = z - w.center.y;
  const along = dx * w.dir.x + dz * w.dir.y;
  const perp = dx * -w.dir.y + dz * w.dir.x;
  const sigma2A = w.sigmaAlong * w.sigmaAlong;
  const sigma2P = w.sigmaAcross * w.sigmaAcross;
  const height =
    w.amplitude *
    Math.exp(-(along * along) / (2 * sigma2A) - (perp * perp) / (2 * sigma2P));
  const dE_dx = -(along * w.dir.x) / sigma2A + (perp * w.dir.y) / sigma2P;
  const dE_dz = -(along * w.dir.y) / sigma2A - (perp * w.dir.x) / sigma2P;
  return { height, dHdx: height * dE_dx, dHdz: height * dE_dz };
}

function sampleWave(x, z) {
  let height = 0;
  let dHdx = 0;
  let dHdz = 0;
  for (const w of waves) {
    const s = sampleSingleWave(w, x, z);
    height += s.height;
    dHdx += s.dHdx;
    dHdz += s.dHdz;
  }
  const atten = edgeFalloff(x, z);
  return { height: height * atten, dHdx: dHdx * atten, dHdz: dHdz * atten };
}

function sampleGerstner(x, z, time) {
  let h = 0;
  let gx = 0;
  let gz = 0;
  for (const w of gerstnerWaves) {
    const k = (Math.PI * 2) / w.len;
    const phase = k * (w.dir.x * x + w.dir.y * z) + w.speed * time;
    const s = Math.sin(phase);
    const c = Math.cos(phase);
    h += w.amp * s;
    const grad = w.amp * k * c;
    gx += grad * w.dir.x;
    gz += grad * w.dir.y;
  }
  return { height: h, gradX: gx, gradZ: gz };
}

function edgeFalloff(x, z) {
  const half = groundSize * 0.5;
  const fx = THREE.MathUtils.clamp(1 - Math.abs(x) / half, 0, 1);
  const fz = THREE.MathUtils.clamp(1 - Math.abs(z) / half, 0, 1);
  return Math.pow(Math.min(fx, fz), 1.2);
}

function getGroundInfo(x, z) {
  const sample = sampleWave(x, z);
  const normal = new THREE.Vector3(-sample.dHdx, 1, -sample.dHdz).normalize();
  const onWave = sample.height > 0.05;
  return {
    height: groundBaseHeight + sample.height,
    gradX: sample.dHdx,
    gradZ: sample.dHdz,
    normal,
    onWave,
  };
}

function updateWave(dt) {
  for (const w of waves) {
    if (!w.active) {
      if (w.cooldown > 0) {
        w.cooldown -= dt;
        continue;
      }
      spawnWave(w);
    }
    moveWave(w, dt);
  }
  updateHud();
  updateWaveMesh();
}

function moveWave(w, dt) {
  const delta = w.speed * dt;
  w.center.addScaledVector(w.dir, delta);
  w.traveled += delta;
  if (w.traveled > waveConfig.travelMax) {
    w.active = false;
    w.cooldown =
      waveConfig.respawnDelay[0] +
      Math.random() * (waveConfig.respawnDelay[1] - waveConfig.respawnDelay[0]);
  }
}

function updateWaveMesh() {
  const positions = ground.geometry.attributes.position;
  for (let i = 0; i < positions.count; i++) {
    const x = positions.getX(i);
    const zWorld = -positions.getY(i);
    const h = sampleWave(x, zWorld).height;
    positions.setZ(i, h);
  }
  positions.needsUpdate = true;
  ground.geometry.computeVertexNormals();
}

function updateHud() {
  if (!hudValue) return;
  const active = waves.filter((w) => w.active);
  if (active.length === 0) {
    hudValue.textContent = "â€”";
    hudEl?.classList.remove("pulse");
    hudValue.style.color = "#7ee787";
    return;
  }
  const maxAmp = Math.max(...active.map((w) => w.amplitude));
  hudValue.textContent = `${maxAmp.toFixed(1)}m`;
  hudEl?.classList.add("pulse");
}

function spawnWave(w) {
  const angle = Math.random() * Math.PI * 2;
  w.dir.set(Math.cos(angle), Math.sin(angle)).normalize();
  const perp = new THREE.Vector2(-w.dir.y, w.dir.x);
  const offset = (Math.random() * 600) - 300;
  w.center.copy(w.dir).multiplyScalar(-waveConfig.spawnDistance).addScaledVector(perp, offset);
  w.amplitude =
    waveConfig.ampMin + Math.random() * (waveConfig.ampMax - waveConfig.ampMin);
  w.speed =
    waveConfig.speedMin + Math.random() * (waveConfig.speedMax - waveConfig.speedMin);
  w.sigmaAlong = waveConfig.sigmaAlong;
  w.sigmaAcross = waveConfig.sigmaAcross;
  w.traveled = 0;
  w.active = true;
}

function applyGerstnerWaves(material) {
  material.userData.gerstner = { waves: gerstnerWaves, uniforms: null };

  material.onBeforeCompile = (shader) => {
    shader.uniforms.uTime = { value: 0 };
    shader.uniforms.uDir = { value: gerstnerWaves.map((w) => w.dir) };
    shader.uniforms.uWaves = {
      value: gerstnerWaves.map((w) => new THREE.Vector4(w.amp, w.len, w.speed, w.steep)),
    };
    material.userData.gerstner.uniforms = shader.uniforms;

    shader.vertexShader = shader.vertexShader.replace(
      "#include <common>",
      `
      #include <common>
      uniform float uTime;
      uniform vec2 uDir[3];
      uniform vec4 uWaves[3];

      void applyGerstner(vec3 pos, out vec3 displaced, out vec3 gNormal) {
        vec3 disp = pos;
        float dHdx = 0.0;
        float dHdy = 0.0;

        for (int i = 0; i < 3; i++) {
          vec2 dir = normalize(uDir[i]);
          float amp = uWaves[i].x;
          float len = uWaves[i].y;
          float spd = uWaves[i].z;
          float steep = uWaves[i].w;
          float k = 6.28318530718 / len;
          float phase = k * (dir.x * pos.x + dir.y * pos.y) + spd * uTime;
          float s = sin(phase);
          float c = cos(phase);

          disp.x += dir.x * (steep * amp * c);
          disp.y += dir.y * (steep * amp * c);
          disp.z += amp * s;

          dHdx += amp * k * c * dir.x;
          dHdy += amp * k * c * dir.y;
        }

        displaced = disp;
        gNormal = normalize(vec3(-dHdx, -dHdy, 1.0));
      }
      `
    );

      shader.vertexShader = shader.vertexShader.replace(
        "#include <beginnormal_vertex>",
        `
        vec3 displacedPos;
        vec3 gNormal;
        applyGerstner(vec3(position), displacedPos, gNormal);
        vec3 objectNormal = gNormal;
        `
      );

      shader.vertexShader = shader.vertexShader.replace(
        "#include <begin_vertex>",
        `
        vec3 transformed = displacedPos;
        `
      );
    };
  }

function updateGerstnerTime(time) {
  const g = groundMaterial.userData.gerstner;
  if (g && g.uniforms) {
    g.uniforms.uTime.value = time;
  }
}

